
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/iParadigms/walker/console/controllers.go</option>
				
				<option value="file1">github.com/iParadigms/walker/console/model.go</option>
				
				<option value="file2">github.com/iParadigms/walker/console/rendering.go</option>
				
				<option value="file3">github.com/iParadigms/walker/console/spoof.go</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >/*
        This file contains the web-facing handlers.
*/
package console

import (
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "code.google.com/p/log4go"
        "github.com/gorilla/mux"
        "github.com/iParadigms/walker"
)

type Route struct {
        Path       string
        Controller func(w http.ResponseWriter, req *http.Request)
}

func Routes() []Route <span class="cov0" title="0">{
        return []Route{
                Route{Path: "/", Controller: HomeController},
                Route{Path: "/list", Controller: ListDomainsController},
                Route{Path: "/list/", Controller: ListDomainsController},
                Route{Path: "/list/{seed}", Controller: ListDomainsController},
                Route{Path: "/find", Controller: FindDomainController},
                Route{Path: "/find/", Controller: FindDomainController},
                Route{Path: "/add", Controller: AddLinkIndexController},
                Route{Path: "/add/", Controller: AddLinkIndexController},
                Route{Path: "/links/{domain}", Controller: LinksController},
                Route{Path: "/links/{domain}/{seedUrl}", Controller: LinksController},
                Route{Path: "/historical/{url}", Controller: LinksHistoricalController},
                Route{Path: "/findLinks", Controller: FindLinksController},
        }
}</span>

func HomeController(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        mp := map[string]interface{}{}
        Render.HTML(w, http.StatusOK, "home", mp)
        return
}</span>

func ListDomainsController(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(req)
        seed := vars["seed"]
        prevButtonClass := ""
        if seed == "" </span><span class="cov8" title="1">{
                seed = DontSeedDomain
                prevButtonClass = "disabled"
        }</span> <span class="cov0" title="0">else {
                var err error
                seed, err = url.QueryUnescape(seed)
                if err != nil </span><span class="cov0" title="0">{
                        seed = DontSeedDomain
                }</span>
        }

        <span class="cov8" title="1">dinfos, err := DS.ListDomains(seed, PageWindowLength)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("ListDomains failed: %v", err)
                replyServerError(w, err)
                return
        }</span>

        <span class="cov8" title="1">nextDomain := ""
        nextButtonClass := "disabled"
        if len(dinfos) == PageWindowLength </span><span class="cov8" title="1">{
                nextDomain = url.QueryEscape(dinfos[len(dinfos)-1].Domain)
                nextButtonClass = ""
        }</span>

        <span class="cov8" title="1">mp := map[string]interface{}{
                "PrevButtonClass": prevButtonClass,
                "NextButtonClass": nextButtonClass,
                "Domains":         dinfos,
                "Next":            nextDomain,
        }
        Render.HTML(w, http.StatusOK, "list", mp)</span>
}

func FindDomainController(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Method != "POST" </span><span class="cov8" title="1">{
                mp := map[string]interface{}{}
                Render.HTML(w, http.StatusOK, "find", mp)
                return
        }</span>

        <span class="cov8" title="1">err := req.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                replyServerError(w, err)
                return
        }</span>

        <span class="cov8" title="1">targetAll, ok := req.Form["targets"]
        if !ok || len(targetAll) &lt; 1 </span><span class="cov0" title="0">{
                log4go.Error("Targets was not defined correctly %v", targetAll)
                mp := map[string]interface{}{}
                Render.HTML(w, http.StatusOK, "find", mp)
                return
        }</span>

        <span class="cov8" title="1">rawLines := targetAll[0]
        lines := strings.Split(rawLines, "\n")
        targets := []string{}
        for i := range lines </span><span class="cov8" title="1">{
                t := strings.TrimSpace(lines[i])
                if t != "" </span><span class="cov8" title="1">{
                        targets = append(targets, t)
                }</span>
        }

        <span class="cov8" title="1">if len(targets) &lt;= 0 </span><span class="cov0" title="0">{
                mp := map[string]interface{}{
                        "HasInfoMessage": true,
                        "InfoMessage":    "Failed to specify any targets",
                }
                Render.HTML(w, http.StatusOK, "find", mp)
                return
        }</span>

        <span class="cov8" title="1">var dinfos []DomainInfo
        var errs []string
        var info []string
        for _, target := range targets </span><span class="cov8" title="1">{
                dinfo, err := DS.FindDomain(target)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("FindDomain failed: %v", err))
                        continue</span>
                }

                <span class="cov8" title="1">if dinfo == nil </span><span class="cov8" title="1">{
                        info = append(info, fmt.Sprintf("Failed to find domain %s", target))
                        continue</span>
                }

                <span class="cov8" title="1">dinfos = append(dinfos, *dinfo)</span>
        }

        <span class="cov8" title="1">hasInfoMessage := len(info) &gt; 0
        hasErrorMessage := len(errs) &gt; 0

        if len(dinfos) == 0 </span><span class="cov8" title="1">{
                info = append(info, "Didn't find any links on previous try")
                hasInfoMessage = true
                mp := map[string]interface{}{
                        "HasInfoMessage":  hasInfoMessage,
                        "InfoMessage":     info,
                        "HasErrorMessage": hasErrorMessage,
                        "ErrorMessage":    errs,
                }
                Render.HTML(w, http.StatusOK, "find", mp)
        }</span> <span class="cov8" title="1">else {
                mp := map[string]interface{}{
                        "PrevButtonClass": "disabled",
                        "NextButtonClass": "disabled",
                        "Domains":         dinfos,
                        "HasNext":         false,
                        "HasInfoMessage":  hasInfoMessage,
                        "InfoMessage":     info,
                        "HasErrorMessage": hasErrorMessage,
                        "ErrorMessage":    errs,
                }
                Render.HTML(w, http.StatusOK, "list", mp)
        }</span>
}

// TODO: I think that we should have a confirm page after you add the links. But thats
// an advanced feature.
func AddLinkIndexController(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Method != "POST" </span><span class="cov8" title="1">{
                mp := map[string]interface{}{}
                Render.HTML(w, http.StatusOK, "add", mp)
                return
        }</span>

        <span class="cov8" title="1">err := req.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                replyServerError(w, err)
                return
        }</span>

        <span class="cov8" title="1">linksExt, ok := req.Form["links"]
        if !ok </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("Corrupt POST message: no links field"))
                return
        }</span>

        <span class="cov8" title="1">text := linksExt[0]
        lines := strings.Split(text, "\n")
        links := make([]string, 0, len(lines))
        var errs []string
        for i := range lines </span><span class="cov8" title="1">{
                u := strings.TrimSpace(lines[i])
                if u == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">uc := urlCleanse(u)
                if uc == "" </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("Unacceptable scheme for '%v'", u))
                        continue</span>
                }
                <span class="cov8" title="1">u = uc

                links = append(links, u)</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                mp := map[string]interface{}{
                        "HasText":         true,
                        "Text":            text,
                        "HasInfoMessage":  true,
                        "InfoMessage":     []string{"No links added"},
                        "HasErrorMessage": true,
                        "ErrorMessage":    errs,
                }
                Render.HTML(w, http.StatusOK, "add", mp)
                return
        }</span>

        <span class="cov8" title="1">errList := DS.InsertLinks(links)
        if len(errList) != 0 </span><span class="cov0" title="0">{
                for _, e := range errList </span><span class="cov0" title="0">{
                        errs = append(errs, e.Error())
                }</span>
                <span class="cov0" title="0">mp := map[string]interface{}{
                        "HasErrorMessage": true,
                        "ErrorMessage":    errs,
                }
                Render.HTML(w, http.StatusOK, "add", mp)
                return</span>
        }

        <span class="cov8" title="1">mp := map[string]interface{}{
                "HasInfoMessage": true,
                "InfoMessage":    []string{"All links added"},
        }
        Render.HTML(w, http.StatusOK, "add", mp)
        return</span>
}

//IMPL NOTE: Why does linksController encode the seedUrl in base32, rather than URL encode it?
// The reason is that various components along the way are tripping on the appearance of the
// seedUrl argument. First, it appears that the browser is unencoding the link BEFORE submitting it
// to the server. That looks like a problem with the browser to me. But in addition, the server appears
// to be choking on the url-encoded text as well. For example if the url encoded seedUrl ends with
// .html, it appears that this is causing the server to throw a 301. Unknown why that is. But the net effect
// is that, if I totally disguise the link in base32, everything works.

func LinksController(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(req)
        domain := vars["domain"]
        if domain == "" </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("User failed to specify domain for linksController"))
                return
        }</span>
        <span class="cov8" title="1">dinfo, err := DS.FindDomain(domain)
        if err != nil </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("FindDomain: %v", err))
                return
        }</span>

        <span class="cov8" title="1">if dinfo == nil </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("User failed to specify domain for linksController"))
                return
        }</span>

        <span class="cov8" title="1">seedUrl := vars["seedUrl"]
        needHeader := false
        windowLength := PageWindowLength
        prevButtonClass := ""
        if seedUrl == "" </span><span class="cov8" title="1">{
                needHeader = true
                windowLength /= 2
                prevButtonClass = "disabled"
        }</span> <span class="cov8" title="1">else {
                ss, err := decode32(seedUrl)
                if err != nil </span><span class="cov0" title="0">{
                        replyServerError(w, fmt.Errorf("QueryUnescape: %v", err))
                        return
                }</span>
                <span class="cov8" title="1">seedUrl = ss</span>
        }

        <span class="cov8" title="1">linfos, err := DS.ListLinks(domain, seedUrl, windowLength)
        if err != nil </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("ListLinks: %v", err))
                return
        }</span>

        <span class="cov8" title="1">nextSeedUrl := ""
        nextButtonClass := "disabled"
        if len(linfos) == windowLength </span><span class="cov8" title="1">{
                nextSeedUrl = encode32(linfos[len(linfos)-1].Url)
                nextButtonClass = ""
        }</span>

        <span class="cov8" title="1">var historyLinks []string
        for _, linfo := range linfos </span><span class="cov8" title="1">{
                path := "/historical/" + encode32(linfo.Url)
                historyLinks = append(historyLinks, path)
        }</span>

        <span class="cov8" title="1">mp := map[string]interface{}{
                "Dinfo":           dinfo,
                "HasHeader":       needHeader,
                "HasLinks":        len(linfos) &gt; 0,
                "Linfos":          linfos,
                "NextSeedUrl":     nextSeedUrl,
                "NextButtonClass": nextButtonClass,
                "PrevButtonClass": prevButtonClass,
                "HistoryLinks":    historyLinks,
        }
        Render.HTML(w, http.StatusOK, "links", mp)
        return</span>
}

func LinksHistoricalController(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(req)
        url := vars["url"]
        if url == "" </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("linksHistoricalController called without url"))
                return
        }</span>
        <span class="cov8" title="1">nurl, err := decode32(url)
        if err != nil </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("decode32 (%s): %v", url, err))
                return
        }</span>
        <span class="cov8" title="1">url = nurl

        linfos, _, err := DS.ListLinkHistorical(url, DontSeedIndex, 500)
        if err != nil </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("ListLinkHistorical (%s): %v", url, err))
                return
        }</span>

        <span class="cov8" title="1">mp := map[string]interface{}{
                "LinkTopic": url,
                "Linfos":    linfos,
        }
        Render.HTML(w, http.StatusOK, "historical", mp)</span>
}

func FindLinksController(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Method != "POST" </span><span class="cov8" title="1">{
                mp := map[string]interface{}{}
                Render.HTML(w, http.StatusOK, "findLinks", mp)
                return
        }</span>

        <span class="cov8" title="1">err := req.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                replyServerError(w, err)
                return
        }</span>

        <span class="cov8" title="1">linksExt, ok := req.Form["links"]
        if !ok </span><span class="cov0" title="0">{
                replyServerError(w, fmt.Errorf("Corrupt POST message: no links field"))
                return
        }</span>

        <span class="cov8" title="1">text := linksExt[0]
        lines := strings.Split(text, "\n")
        var info []string
        var errs []string
        var linfos []LinkInfo
        for i := range lines </span><span class="cov8" title="1">{
                u := strings.TrimSpace(lines[i])
                if u == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">uc := urlCleanse(u)
                if uc == "" </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("Unacceptable scheme for '%v'", u))
                        continue</span>
                }
                <span class="cov8" title="1">u = uc

                linfo, err := DS.FindLink(u)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("FindLinks error: %v", err))
                        continue</span>
                } <span class="cov8" title="1">else if linfo == nil </span><span class="cov0" title="0">{
                        info = append(info, fmt.Sprintf("Failed to find link '%v'", u))
                        continue</span>
                }
                <span class="cov8" title="1">linfos = append(linfos, *linfo)</span>
        }

        <span class="cov8" title="1">needErr := len(errs) &gt; 0
        needInf := len(info) &gt; 0

        if len(linfos) == 0 </span><span class="cov0" title="0">{
                info = append(info, "Failed to find any links")
                mp := map[string]interface{}{
                        "Text":            text,
                        "HasError":        needErr,
                        "HasInfoMessage":  true,
                        "InfoMessage":     info,
                        "HasErrorMessage": needErr,
                        "ErrorMessage":    errs,
                }
                Render.HTML(w, http.StatusOK, "findLinks", mp)
                return
        }</span>

        <span class="cov8" title="1">var historyLinks []string
        for _, linfo := range linfos </span><span class="cov8" title="1">{
                path := "/historical/" + encode32(linfo.Url)
                historyLinks = append(historyLinks, path)
        }</span>

        <span class="cov8" title="1">mp := map[string]interface{}{
                "HasLinks":       true,
                "Linfos":         linfos,
                "DisableButtons": true,
                "AltTitle":       true,
                "HistoryLinks":   historyLinks,

                "HasInfoMessage":  needInf,
                "InfoMessage":     info,
                "HasErrorMessage": needErr,
                "ErrorMessage":    errs,
        }

        Render.HTML(w, http.StatusOK, "links", mp)
        return</span>
}

// UTILITY
// urlCleanse returns a URL with an acceptable scheme, or the empty string
// if no acceptable scheme is present. In the event the scheme is not provided,
// http is assumed. NOTE: There is a similar function in walker proper. When
// we get to the point of refactoring the data models together, this can be
// merged.
func urlCleanse(url string) string <span class="cov8" title="1">{
        index := strings.LastIndex(url, ":")
        if index &lt; 0 </span><span class="cov0" title="0">{
                return "http://" + url
        }</span>

        <span class="cov8" title="1">scheme := url[:index]
        for _, f := range walker.Config.AcceptProtocols </span><span class="cov8" title="1">{
                if scheme == f </span><span class="cov8" title="1">{
                        return url
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
        Model contains data source related code.
*/

package console

import (
        "fmt"
        "time"

        "github.com/gocql/gocql"
        "github.com/iParadigms/walker"
)

type DomainInfo struct {
        //TLD+1
        Domain string

        //Why did this domain get excluded, or empty if not excluded
        ExcludeReason string

        //When did this domain last get queued to be crawled. Or TimeQueed.IsZero() if not crawled
        TimeQueued time.Time

        //What was the UUID of the crawler that last crawled the domain
        UuidOfQueued gocql.UUID

        //Number of (unique) links found in this domain
        NumberLinksTotal int

        //Number of (unique) links queued to be processed for this domain
        NumberLinksQueued int
}

type LinkInfo struct {
        //URL of the link
        Url string

        //Status of the GET
        Status int

        //Any error reported during the get
        Error string

        //Was this excluded by robots
        RobotsExcluded bool

        //When did this link get crawled
        CrawlTime time.Time
}

//
//DataStore represents all the interaction the application has with the datastore.
//
const DontSeedDomain = ""
const DontSeedUrl = ""
const DontSeedIndex = 0

type Model interface {
        //INTERFACE NOTE: any place you see a seed variable that is a string/timestamp
        // that represents the last value of the previous call. limit is the max number
        // of results returned. seed and limit are used to implement pagination.

        // Close the data store after you're done with it
        Close()

        // InsertLinks queues a set of URLS to be crawled
        InsertLinks(links []string) []error

        // Find a specific domain
        FindDomain(domain string) (*DomainInfo, error)

        // List domains
        ListDomains(seedDomain string, limit int) ([]DomainInfo, error)

        // Same as ListDomains, but only lists the domains that are currently queued
        ListWorkingDomains(seedDomain string, limit int) ([]DomainInfo, error)

        // List links from the given domain
        ListLinks(domain string, seedUrl string, limit int) ([]LinkInfo, error)

        // For a given linkUrl, return the entire crawl history
        ListLinkHistorical(linkUrl string, seedIndex int, limit int) ([]LinkInfo, int, error)

        // Find a link
        FindLink(links string) (*LinkInfo, error)
}

var DS Model

//
// Cassandra DataSTore
//
type CqlModel struct {
        Cluster *gocql.ClusterConfig
        Db      *gocql.Session
}

func NewCqlModel() (*CqlModel, error) <span class="cov8" title="1">{
        ds := new(CqlModel)
        ds.Cluster = gocql.NewCluster(walker.Config.Cassandra.Hosts...)
        ds.Cluster.Keyspace = walker.Config.Cassandra.Keyspace
        var err error
        ds.Db, err = ds.Cluster.CreateSession()
        return ds, err
}</span>

func (ds *CqlModel) Close() <span class="cov8" title="1">{
        ds.Db.Close()
}</span>

//NOTE: part of this is cribbed from walker.datastore.go. Code share?
func (ds *CqlModel) addDomainIfNew(domain string) error <span class="cov8" title="1">{
        var count int
        err := ds.Db.Query(`SELECT COUNT(*) FROM domain_info WHERE dom = ?`, domain).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("seek; %v", err)
        }</span>

        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                err := ds.Db.Query(`INSERT INTO domain_info (dom) VALUES (?)`, domain).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("insert; %v", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

//NOTE: InsertLinks should try to insert as much information as possible
//return errors for things it can't handle
func (ds *CqlModel) InsertLinks(links []string) []error <span class="cov8" title="1">{
        //
        // Collect domains
        //
        var domains []string
        var errList []error
        var urls []*walker.URL
        for i := range links </span><span class="cov8" title="1">{
                link := links[i]
                url, err := walker.ParseURL(link)
                if err != nil </span><span class="cov0" title="0">{
                        errList = append(errList, fmt.Errorf("%v # ParseURL: %v", link, err))
                        domains = append(domains, "")
                        urls = append(urls, nil)
                        continue</span>
                } <span class="cov8" title="1">else if url.Scheme == "" </span><span class="cov0" title="0">{
                        errList = append(errList, fmt.Errorf("%v # ParseURL: undefined scheme (http:// or https://)", link))
                        domains = append(domains, "")
                        urls = append(urls, nil)
                        continue</span>
                }
                <span class="cov8" title="1">domain := url.ToplevelDomainPlusOne()
                if domain == "" </span><span class="cov0" title="0">{
                        errList = append(errList, fmt.Errorf("%v # ToplevelDomainPlusOne: bad domain", link))
                        domains = append(domains, "")
                        urls = append(urls, nil)
                        continue</span>
                }

                <span class="cov8" title="1">domains = append(domains, domain)
                urls = append(urls, url)</span>
        }

        //
        // Push domain information to table. The only trick to this, is I don't add links unless
        // the domain can be added
        //
        <span class="cov8" title="1">db := ds.Db
        var seen = map[string]bool{}
        for i := range links </span><span class="cov8" title="1">{
                link := links[i]
                d := domains[i]
                u := urls[i]

                // if you already had an error, keep going
                if u == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !seen[d] </span><span class="cov8" title="1">{
                        err := ds.addDomainIfNew(d)
                        if err != nil </span><span class="cov0" title="0">{
                                errList = append(errList, fmt.Errorf("%v # addDomainIfNew: %v", link, err))
                                continue</span>
                        }
                }
                <span class="cov8" title="1">seen[d] = true

                err := db.Query(`INSERT INTO links (dom, subdom, path, proto, time)
                                     VALUES (?, ?, ?, ?, ?)`, d, u.Subdomain(),
                        u.RequestURI(), u.Scheme, walker.NotYetCrawled).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        errList = append(errList, fmt.Errorf("%v # `insert query`: %v", link, err))
                        continue</span>
                }
        }

        <span class="cov8" title="1">return errList</span>
}

func (ds *CqlModel) countUniqueLinks(domain string, table string) (int, error) <span class="cov8" title="1">{
        db := ds.Db
        q := fmt.Sprintf("SELECT subdom, path, proto, time FROM %s WHERE dom = ?", table)
        itr := db.Query(q, domain).Iter()

        var subdomain, path, protocol string
        var crawlTime time.Time
        found := map[string]time.Time{}
        for itr.Scan(&amp;subdomain, &amp;path, &amp;protocol, &amp;crawlTime) </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%s : %s : %s", subdomain, path, protocol)
                t, foundT := found[key]
                if !foundT || t.Before(crawlTime) </span><span class="cov8" title="1">{
                        found[key] = crawlTime
                }</span>
        }
        <span class="cov8" title="1">err := itr.Close()
        return len(found), err</span>
}

func (ds *CqlModel) annotateDomainInfo(dinfos []DomainInfo) error <span class="cov8" title="1">{
        //
        // Count Links
        //
        for i := range dinfos </span><span class="cov8" title="1">{
                d := &amp;dinfos[i]

                linkCount, err := ds.countUniqueLinks(d.Domain, "links")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.NumberLinksTotal = linkCount

                d.NumberLinksQueued = 0
                if d.TimeQueued != zeroTime </span><span class="cov8" title="1">{
                        segmentCount, err := ds.countUniqueLinks(d.Domain, "segments")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">d.NumberLinksQueued = segmentCount</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (ds *CqlModel) listDomainsImpl(seed string, limit int, working bool) ([]DomainInfo, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Bad value for limit parameter %d", limit)
        }</span>
        <span class="cov8" title="1">db := ds.Db

        var itr *gocql.Iter
        if seed == "" &amp;&amp; !working </span><span class="cov8" title="1">{
                itr = db.Query("SELECT dom, claim_tok, claim_time FROM domain_info LIMIT ?", limit).Iter()
        }</span> <span class="cov8" title="1">else if seed == "" </span><span class="cov8" title="1">{
                itr = db.Query("SELECT dom, claim_tok, claim_time FROM domain_info WHERE dispatched = true LIMIT ?", limit).Iter()
        }</span> <span class="cov8" title="1">else if !working </span><span class="cov8" title="1">{
                itr = db.Query("SELECT dom, claim_tok, claim_time FROM domain_info WHERE TOKEN(dom) &gt; TOKEN(?) LIMIT ?", seed, limit).Iter()
        }</span> <span class="cov8" title="1">else { //working==true AND seed != ""
                itr = db.Query("SELECT dom, claim_tok, claim_time FROM domain_info WHERE dispatched = true AND TOKEN(dom) &gt; TOKEN(?) LIMIT ?", seed, limit).Iter()
        }</span>

        <span class="cov8" title="1">var dinfos []DomainInfo
        var domain string
        var claim_tok gocql.UUID
        var claim_time time.Time
        for itr.Scan(&amp;domain, &amp;claim_tok, &amp;claim_time) </span><span class="cov8" title="1">{
                dinfos = append(dinfos, DomainInfo{Domain: domain, UuidOfQueued: claim_tok, TimeQueued: claim_time})
        }</span>
        <span class="cov8" title="1">err := itr.Close()
        if err != nil </span><span class="cov0" title="0">{
                return dinfos, err
        }</span>
        <span class="cov8" title="1">err = ds.annotateDomainInfo(dinfos)

        return dinfos, err</span>
}

func (ds *CqlModel) ListDomains(seed string, limit int) ([]DomainInfo, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Bad value for limit parameter %d", limit)
        }</span>
        <span class="cov8" title="1">return ds.listDomainsImpl(seed, limit, false)</span>
}

func (ds *CqlModel) ListWorkingDomains(seedDomain string, limit int) ([]DomainInfo, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Bad value for limit parameter %d", limit)
        }</span>
        <span class="cov8" title="1">return ds.listDomainsImpl(seedDomain, limit, true)</span>
}

//                itr = db.Query("SELECT domain, claim_tok, claim_time FROM domain_info WHERE dispatched = true AND TOKEN(domain) &gt; TOKEN(?) LIMIT ?", seed, limit).Iter()
func (ds *CqlModel) FindDomain(domain string) (*DomainInfo, error) <span class="cov8" title="1">{
        db := ds.Db
        itr := db.Query("SELECT claim_tok, claim_time FROM domain_info WHERE dom = ?", domain).Iter()
        var claim_tok gocql.UUID
        var claim_time time.Time
        if !itr.Scan(&amp;claim_tok, &amp;claim_time) </span><span class="cov8" title="1">{
                err := itr.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">dinfo := &amp;DomainInfo{Domain: domain, UuidOfQueued: claim_tok, TimeQueued: claim_time}
        err := itr.Close()
        if err != nil </span><span class="cov0" title="0">{
                return dinfo, err
        }</span>

        <span class="cov8" title="1">dinfos := []DomainInfo{*dinfo}
        err = ds.annotateDomainInfo(dinfos)
        *dinfo = dinfos[0]
        return dinfo, err</span>
}

// Pagination note:
// To paginate a single column you can do
//
//   SELECT a FROM table WHERE a &gt; startingA
//
// If you have two columns though, it requires two queries
//
//   SELECT a,b from table WHERE a == startingA AND b &gt; startingB
//   SELECT a,b from table WHERE a &gt; startingA
//
// With 3 columns it looks like this
//
//   SELECT a,b,c FROM table WHERE a == startingA AND b == startingB AND c &gt; startingC
//   SELECT a,b,c FROM table WHERE a == startingA AND b &gt; startingB
//   SELECT a,b,c FROM table WHERE a &gt; startingA
//
// Particularly for our links table, with primary key domain, subdomain, path, protocol, crawl_time
// For right now, ignore the crawl time we write
//
// SELECT * FROM links WHERE domain = startDomain AND subdomain = startSubDomain AND path = startPath
//                           AND protocol &gt; startProtocol
// SELECT * FROM links WHERE domain = startDomain AND subdomain = startSubDomain AND path &gt; startPath
// SELECT * FROM links WHERE domain = startDomain AND subdomain &gt; startSubDomain
//
// Now the only piece left, is that crawl_time is part of the primary key. Generally we're only going to take the latest crawl time. But see
// Historical query
//

type rememberTimes struct {
        ctm time.Time
        ind int
}

//collectLinkInfos populates a []LinkInfo list given a cassandra iterator
func (ds *CqlModel) collectLinkInfos(linfos []LinkInfo, rtimes map[string]rememberTimes, itr *gocql.Iter, limit int) ([]LinkInfo, error) <span class="cov8" title="1">{
        var domain, subdomain, path, protocol, anerror string
        var crawlTime time.Time
        var robotsExcluded bool
        var status int

        for itr.Scan(&amp;domain, &amp;subdomain, &amp;path, &amp;protocol, &amp;crawlTime, &amp;status, &amp;anerror, &amp;robotsExcluded) </span><span class="cov8" title="1">{

                u, err := walker.CreateURL(domain, subdomain, path, protocol, crawlTime)
                if err != nil </span><span class="cov0" title="0">{
                        return linfos, err
                }</span>
                <span class="cov8" title="1">urlString := u.String()

                qq, yes := rtimes[urlString]

                if yes &amp;&amp; qq.ctm.After(crawlTime) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">linfo := LinkInfo{
                        Url:            urlString,
                        Status:         status,
                        Error:          anerror,
                        RobotsExcluded: robotsExcluded,
                        CrawlTime:      crawlTime,
                }

                nindex := -1
                if yes </span><span class="cov8" title="1">{
                        nindex = qq.ind
                        linfos[qq.ind] = linfo
                }</span> <span class="cov8" title="1">else {
                        linfos = append(linfos, linfo)
                        nindex = len(linfos) - 1
                }</span>
                <span class="cov8" title="1">rtimes[urlString] = rememberTimes{ctm: crawlTime, ind: nindex}

                if len(linfos) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return linfos, nil</span>
}

type queryEntry struct {
        query string
        args  []interface{}
}

func (ds *CqlModel) ListLinks(domain string, seedUrl string, limit int) ([]LinkInfo, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Bad value for limit parameter %d", limit)
        }</span>
        <span class="cov8" title="1">db := ds.Db
        var linfos []LinkInfo
        rtimes := map[string]rememberTimes{}
        var table []queryEntry

        if seedUrl == "" </span><span class="cov8" title="1">{
                table = []queryEntry{
                        queryEntry{
                                query: `SELECT dom, subdom, path, proto, time, stat, err, robot_ex
                      FROM links 
                      WHERE dom = ?`,
                                args: []interface{}{domain},
                        },
                }
        }</span> <span class="cov8" title="1">else {
                u, err := walker.ParseURL(seedUrl)
                if err != nil </span><span class="cov0" title="0">{
                        return linfos, err
                }</span>
                <span class="cov8" title="1">dom := u.ToplevelDomainPlusOne()
                sub := u.Subdomain()
                pat := u.RequestURI()
                pro := u.Scheme

                table = []queryEntry{
                        queryEntry{
                                query: `SELECT dom, subdom, path, proto, time, stat, err, robot_ex
                      FROM links 
                      WHERE dom = ? AND 
                            subdom = ? AND 
                            path = ? AND 
                            proto &gt; ?`,
                                args: []interface{}{dom, sub, pat, pro},
                        },
                        queryEntry{
                                query: `SELECT dom, subdom, path, proto, time, stat, err, robot_ex 
                      FROM links 
                      WHERE dom = ? AND 
                            subdom = ? AND 
                            path &gt; ?`,
                                args: []interface{}{dom, sub, pat},
                        },
                        queryEntry{
                                query: `SELECT dom, subdom, path, proto, time, stat, err, robot_ex 
                      FROM links 
                      WHERE dom = ? AND 
                            subdom &gt; ?`,
                                args: []interface{}{dom, sub},
                        },
                }</span>
        }

        <span class="cov8" title="1">var err error
        for _, qt := range table </span><span class="cov8" title="1">{
                itr := db.Query(qt.query, qt.args...).Iter()
                linfos, err = ds.collectLinkInfos(linfos, rtimes, itr, limit)
                if err != nil </span><span class="cov0" title="0">{
                        return linfos, err
                }</span>

                <span class="cov8" title="1">err = itr.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return linfos, err
                }</span> <span class="cov8" title="1">else if len(linfos) &gt;= limit </span><span class="cov8" title="1">{
                        return linfos, nil
                }</span>
        }

        <span class="cov8" title="1">return linfos, nil</span>
}

func (ds *CqlModel) ListLinkHistorical(linkUrl string, seedIndex int, limit int) ([]LinkInfo, int, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, seedIndex, fmt.Errorf("Bad value for limit parameter %d", limit)
        }</span>
        <span class="cov8" title="1">db := ds.Db
        u, err := walker.ParseURL(linkUrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, seedIndex, err
        }</span>

        <span class="cov8" title="1">query := `SELECT dom, subdom, path, proto, time, stat, err, robot_ex 
              FROM links
              WHERE dom = ? AND subdom = ? AND path = ? AND proto = ?`
        itr := db.Query(query, u.ToplevelDomainPlusOne(), u.Subdomain(), u.RequestURI(), u.Scheme).Iter()

        var linfos []LinkInfo
        var dom, sub, path, prot, getError string
        var crawlTime time.Time
        var status int
        var robotsExcluded bool
        count := 0
        for itr.Scan(&amp;dom, &amp;sub, &amp;path, &amp;prot, &amp;crawlTime, &amp;status, &amp;getError, &amp;robotsExcluded) </span><span class="cov8" title="1">{
                if count &lt; seedIndex </span><span class="cov8" title="1">{
                        count++
                        continue</span>
                }

                <span class="cov8" title="1">url, _ := walker.CreateURL(dom, sub, path, prot, crawlTime)
                linfo := LinkInfo{
                        Url:            url.String(),
                        Status:         status,
                        Error:          getError,
                        RobotsExcluded: robotsExcluded,
                        CrawlTime:      crawlTime,
                }
                linfos = append(linfos, linfo)
                if len(linfos) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">err = itr.Close()

        return linfos, seedIndex + len(linfos), err</span>
}

func (ds *CqlModel) FindLink(link string) (*LinkInfo, error) <span class="cov8" title="1">{
        db := ds.Db
        u, err := walker.ParseURL(link)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">query := `SELECT dom, subdom, path, proto, time, stat, err, robot_ex 
                      FROM links 
                      WHERE dom = ? AND 
                            subdom = ? AND 
                            path = ? AND 
                            proto = ?`
        itr := db.Query(query, u.ToplevelDomainPlusOne(), u.Subdomain(), u.RequestURI(), u.Scheme).Iter()
        rtimes := map[string]rememberTimes{}
        linfos, err := ds.collectLinkInfos(nil, rtimes, itr, 1)
        if err != nil </span><span class="cov0" title="0">{
                itr.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">err = itr.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(linfos) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span> <span class="cov8" title="1">else {
                return &amp;linfos[0], nil
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
        This file contains functionality related to rendering templates
*/
package console

import (
        "html/template"
        "net/http"
        "os"
        "time"

        "code.google.com/p/log4go"
        "encoding/base32"
        "github.com/gocql/gocql"
        "github.com/iParadigms/walker"
        "github.com/unrolled/render"
)

var zeroTime = time.Time{}
var zeroUuid = gocql.UUID{}
var timeFormat = "2006-01-02 15:04:05 -0700"

const PageWindowLength = 15

func yesOnFilledFunc(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return ""
        }</span> <span class="cov0" title="0">else {
                return "yes"
        }</span>
}

func yesOnTrueFunc(q bool) string <span class="cov8" title="1">{
        if q </span><span class="cov0" title="0">{
                return "yes"
        }</span> <span class="cov8" title="1">else {
                return ""
        }</span>

}

func activeSinceFunc(t time.Time) string <span class="cov8" title="1">{
        if t == zeroTime </span><span class="cov0" title="0">{
                return ""
        }</span> <span class="cov8" title="1">else {
                return t.Format(timeFormat)
        }</span>
}

func ftimeFunc(t time.Time) string <span class="cov8" title="1">{
        if t == zeroTime || t.Equal(walker.NotYetCrawled) </span><span class="cov8" title="1">{
                return "Not yet crawled"
        }</span> <span class="cov8" title="1">else {
                return t.Format(timeFormat)
        }</span>
}

func ftime2Func(t time.Time) string <span class="cov8" title="1">{
        if t == zeroTime || t.Equal(walker.NotYetCrawled) </span><span class="cov8" title="1">{
                return ""
        }</span> <span class="cov8" title="1">else {
                return t.Format(timeFormat)
        }</span>
}

func fuuidFunc(u gocql.UUID) string <span class="cov8" title="1">{
        if u == zeroUuid </span><span class="cov8" title="1">{
                return ""
        }</span> <span class="cov8" title="1">else {
                return u.String()
        }</span>
}

var Render *render.Render

func BuildRender(verbose bool) <span class="cov8" title="1">{
        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                pwd = "UNKNOWN"
        }</span>
        <span class="cov8" title="1">if verbose </span><span class="cov0" title="0">{
                log4go.Info("Setting templates directory to '%s' [pwd=%s]", walker.Config.Console.TemplateDirectory, pwd)
        }</span>
        <span class="cov8" title="1">Render = render.New(render.Options{
                Directory:     walker.Config.Console.TemplateDirectory,
                Layout:        "layout",
                IndentJSON:    true,
                IsDevelopment: true,
                Funcs: []template.FuncMap{
                        template.FuncMap{
                                "yesOnFilled": yesOnFilledFunc,
                                "activeSince": activeSinceFunc,
                                "ftime":       ftimeFunc,
                                "ftime2":      ftime2Func,
                                "fuuid":       fuuidFunc,
                                "statusText":  http.StatusText,
                                "yesOnTrue":   yesOnTrueFunc,
                        },
                },
        })</span>
}

func replyServerError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        log4go.Error("Rendering 500: %v", err)
        mp := map[string]interface{}{
                "anErrorHappend": true,
                "theError":       err.Error(),
        }
        Render.HTML(w, http.StatusInternalServerError, "serverError", mp)
        return
}</span>

// Some Utilities
func decode32(s string) (string, error) <span class="cov8" title="1">{
        b, err := base32.StdEncoding.DecodeString(s)
        return string(b), err
}</span>

func encode32(s string) string <span class="cov8" title="1">{
        b := base32.StdEncoding.EncodeToString([]byte(s))
        return string(b)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
        This file has some temporary code designed to populate a cassandra datastore
        with some test data. The code isn't a picture of beauty, but it won't live that long.
*/

package console

import (
        "fmt"
        "math/rand"
        "net/http"
        "sync"
        "time"

        "github.com/gocql/gocql"
        "github.com/iParadigms/walker"
)

var spoofRun sync.Once

func SpoofData() <span class="cov8" title="1">{
        spoofRun.Do(func() </span><span class="cov8" title="1">{
                spoofDataLong()
        }</span>)
}

func spoofDataLong() <span class="cov8" title="1">{
        if walker.Config.Cassandra.Keyspace == "walker" </span><span class="cov0" title="0">{
                panic("Not allowed to spoof the walker keyspace")
        }</span>

        //
        // Drop the keyspace if it exists
        //
        <span class="cov8" title="1">{
                cluster := gocql.NewCluster(walker.Config.Cassandra.Hosts...)
                //cluster.Keyspace = walker.Config.Cassandra.Keyspace
                db, err := cluster.CreateSession()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)
                }</span>

                <span class="cov8" title="1">err = db.Query(fmt.Sprintf("DROP KEYSPACE IF EXISTS %s", walker.Config.Cassandra.Keyspace)).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Failed to drop %s keyspace: %v", walker.Config.Cassandra.Keyspace, err))
                }</span>
                <span class="cov8" title="1">db.Close()</span>
        }

        //
        // Build the new schema
        //
        <span class="cov8" title="1">err := walker.CreateCassandraSchema()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)
        }</span>

        //
        // Build data store
        //
        <span class="cov8" title="1">ds, err := NewCqlModel()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("Failed to start data source: %v", err))
        }</span>
        <span class="cov8" title="1">db := ds.Db

        //
        // Clear out the tables first
        //
        tables := []string{"links", "segments", "domain_info"}
        for _, table := range tables </span><span class="cov8" title="1">{
                err := db.Query(fmt.Sprintf(`TRUNCATE %v`, table)).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Failed to truncate table %v: %v", table, err))
                }</span>
        }

        <span class="cov8" title="1">rand.Seed(42)

        insertDomainInfo := `INSERT INTO domain_info (dom) VALUES (?)`
        insertDomainToCrawl := `INSERT INTO domain_info (dom, claim_tok, claim_time) VALUES (?, ?, ?)`
        insertSegment := `INSERT INTO segments (dom, subdom, path, proto) VALUES (?, ?, ?, ?)`
        insertLink := `INSERT INTO links (dom, subdom, path, proto, time, stat, err, robot_ex) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`

        for i := 0; i &lt; 100; i++ </span><span class="cov8" title="1">{
                domain := fmt.Sprintf("x%d.com", i)
                err := db.Query(insertDomainInfo, domain).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)
                }</span>
                <span class="cov8" title="1">crawlTime := fakeCrawlTime()
                status := fakeStatus()
                excluded := false
                if rand.Float32() &lt; 0.1 </span><span class="cov8" title="1">{
                        status = http.StatusOK
                        crawlTime = walker.NotYetCrawled
                        excluded = true
                }</span>
                <span class="cov8" title="1">err = db.Query(insertLink, domain, "subd", "/page1.html", "http", crawlTime, status, "", excluded).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)
                }</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                domain := fmt.Sprintf("y%d.com", i)
                err := db.Query(insertDomainInfo, domain).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; 100; i++ </span><span class="cov8" title="1">{
                        crawlTime := fakeCrawlTime()
                        status := fakeStatus()
                        excluded := false
                        if rand.Float32() &lt; 0.1 </span><span class="cov8" title="1">{
                                status = http.StatusOK
                                crawlTime = walker.NotYetCrawled
                                excluded = true
                        }</span>
                        <span class="cov8" title="1">page := fmt.Sprintf("/page%d.html", i)
                        err = db.Query(insertLink, domain, "link", page, "http", crawlTime, status, "", excluded).Exec()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)
                        }</span>
                }
        }

        <span class="cov8" title="1">errorBC := []string{
                "Something very bad happened",
                "Program failed to parse message 5",
                "All your base are belong to us",
                "The Tragically Hip sensor failed",
        }

        for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                domain := fmt.Sprintf("h%d.com", i)
                err := db.Query(insertDomainInfo, domain).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)
                }</span>

                <span class="cov8" title="1">crawlTime := time.Now()
                for i := 0; i &lt; 20; i++ </span><span class="cov8" title="1">{
                        crawlTime = crawlTime.AddDate(0, 0, -rand.Intn(30))
                        status := fakeStatus()
                        fakeError := ""
                        if rand.Float32() &lt; 0.1 </span><span class="cov8" title="1">{
                                status = http.StatusOK
                                fakeError = errorBC[rand.Intn(len(errorBC))]
                        }</span>
                        <span class="cov8" title="1">err = db.Query(insertLink, domain, "link", "/page1.html", "http", crawlTime, status, fakeError, false).Exec()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)
                        }</span>
                }
        }

        <span class="cov8" title="1">for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                domain := fmt.Sprintf("t%d.com", i)
                uuid := fakeUuid()
                err = db.Query(insertDomainToCrawl, domain, uuid, time.Now()).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; 20; i++ </span><span class="cov8" title="1">{
                        page := fmt.Sprintf("/page%d.html", i)
                        err = db.Query(insertLink, domain, "link", page, "http", walker.NotYetCrawled, http.StatusOK, "", false).Exec()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)
                        }</span>

                        <span class="cov8" title="1">err = db.Query(insertSegment, domain, "", page, "http").Exec()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

func fakeCrawlTime() time.Time <span class="cov8" title="1">{
        t := time.Now().AddDate(-rand.Intn(2), -rand.Intn(6), -rand.Intn(7))
        return t
}</span>

var statusSelect []int = []int{
        http.StatusContinue,
        http.StatusSwitchingProtocols,
        http.StatusOK,
        http.StatusCreated,
        http.StatusAccepted,
        http.StatusNonAuthoritativeInfo,
        http.StatusNoContent,
        http.StatusResetContent,
        http.StatusPartialContent,
        http.StatusMultipleChoices,
        http.StatusMovedPermanently,
        http.StatusFound,
        http.StatusSeeOther,
        http.StatusNotModified,
        http.StatusUseProxy,
        http.StatusTemporaryRedirect,
        http.StatusBadRequest,
        http.StatusUnauthorized,
        http.StatusPaymentRequired,
        http.StatusForbidden,
        http.StatusNotFound,
        http.StatusMethodNotAllowed,
        http.StatusNotAcceptable,
        http.StatusProxyAuthRequired,
        http.StatusRequestTimeout,
        http.StatusConflict,
        http.StatusGone,
        http.StatusLengthRequired,
        http.StatusPreconditionFailed,
        http.StatusRequestEntityTooLarge,
        http.StatusRequestURITooLong,
        http.StatusUnsupportedMediaType,
        http.StatusRequestedRangeNotSatisfiable,
        http.StatusExpectationFailed,
        http.StatusInternalServerError,
        http.StatusNotImplemented,
        http.StatusBadGateway,
        http.StatusServiceUnavailable,
        http.StatusGatewayTimeout,
        http.StatusHTTPVersionNotSupported,
}

func fakeStatus() int <span class="cov8" title="1">{
        if rand.Float32() &lt; 0.8 </span><span class="cov8" title="1">{
                return http.StatusOK
        }</span> <span class="cov8" title="1">else {
                return statusSelect[rand.Intn(len(statusSelect))]
        }</span>
}

var initUuids sync.Once
var selectUuids []gocql.UUID

func fakeUuid() gocql.UUID <span class="cov8" title="1">{
        initUuids.Do(func() </span><span class="cov8" title="1">{
                for i := 0; i &lt; 5; i++ </span><span class="cov8" title="1">{
                        u, err := gocql.RandomUUID()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)
                        }</span>
                        <span class="cov8" title="1">selectUuids = append(selectUuids, u)</span>
                }
        })

        <span class="cov8" title="1">return selectUuids[rand.Intn(len(selectUuids))]</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
